# Hello World Module Example

This example shows how to add a simple "hello" command to pxOS.

## Goal

When the user types "hello", the system responds with "Hello, pxOS user!"

## Implementation Strategy

1. **Parse command**: Detect "hello" in input buffer
2. **Jump to handler**: Call hello command function
3. **Print message**: Display greeting
4. **Return to shell**: Resume shell loop

## Memory Allocation

We'll use sector 2 (loaded at 0x8000) for this module:

```
0x8000 - 0x8010: Command parser extension
0x8010 - 0x8020: hello command handler
0x8020 - 0x8050: Hello message string
```

## Primitive Code

### 1. Load Sector 2 (Add to boot sector)

Add this near the end of the boot sector, before jumping to shell:

```
COMMENT Load extended commands from sector 2
WRITE 0x7C23 0xB4           COMMENT MOV AH, 0x02 (read sectors)
WRITE 0x7C24 0x02
WRITE 0x7C25 0xB0           COMMENT MOV AL, 1 (1 sector)
WRITE 0x7C26 0x01
WRITE 0x7C27 0xB5           COMMENT MOV CH, 0 (cylinder 0)
WRITE 0x7C28 0x00
WRITE 0x7C29 0xB1           COMMENT MOV CL, 2 (sector 2)
WRITE 0x7C2A 0x02
WRITE 0x7C2B 0xB6           COMMENT MOV DH, 0 (head 0)
WRITE 0x7C2C 0x00
WRITE 0x7C2D 0xB2           COMMENT MOV DL, 0 (drive 0 = floppy A)
WRITE 0x7C2E 0x00
WRITE 0x7C2F 0xBB           COMMENT MOV BX, 0x8000 (load address)
WRITE 0x7C30 0x00
WRITE 0x7C31 0x80
WRITE 0x7C32 0xCD           COMMENT INT 0x13 (disk read)
WRITE 0x7C33 0x13
```

### 2. Command Parser Extension

Modify shell_loop to check for "hello" command:

```
COMMENT In shell_loop, after reading Enter key:
COMMENT Check if input is "hello"

DEFINE check_hello 0x7C60

COMMENT Compare first 5 chars of input buffer with "hello"
WRITE 0x7C60 0xBE           COMMENT MOV SI, input_buffer
WRITE 0x7C61 0x10
WRITE 0x7C62 0x7E
WRITE 0x7C63 0xBF           COMMENT MOV DI, hello_cmd_str
WRITE 0x7C64 0x20
WRITE 0x7C65 0x80
WRITE 0x7C66 0xB9           COMMENT MOV CX, 5 (length of "hello")
WRITE 0x7C67 0x05
WRITE 0x7C68 0x00
WRITE 0x7C69 0xF3           COMMENT REPE CMPSB (compare strings)
WRITE 0x7C6A 0xA6
WRITE 0x7C6B 0x74           COMMENT JE do_hello (if equal)
WRITE 0x7C6C 0x03
WRITE 0x7C6D 0xE9           COMMENT JMP shell_loop (continue)
WRITE 0x7C6E 0xC8
WRITE 0x7C6F 0xFF
```

### 3. Hello Command Handler (Sector 2)

Create a new file: `hello_module_sector2.txt`

```
COMMENT ========================================
COMMENT Sector 2: Extended Commands Module
COMMENT Load address: 0x8000
COMMENT ========================================

COMMENT Define command string for comparison
DEFINE hello_cmd_str 0x8020
WRITE 0x8020 0x68           COMMENT 'h'
WRITE 0x8021 0x65           COMMENT 'e'
WRITE 0x8022 0x6C           COMMENT 'l'
WRITE 0x8023 0x6C           COMMENT 'l'
WRITE 0x8024 0x6F           COMMENT 'o'
WRITE 0x8025 0x00           COMMENT null terminator

COMMENT Define hello command handler
DEFINE do_hello 0x8010

WRITE 0x8010 0xBE           COMMENT MOV SI, hello_msg
WRITE 0x8011 0x30
WRITE 0x8012 0x80
WRITE 0x8013 0xE8           COMMENT CALL print_string
WRITE 0x8014 0x12
WRITE 0x8015 0xF4           COMMENT Note: Calculate offset to print_string
WRITE 0x8016 0xE9           COMMENT JMP shell_loop
WRITE 0x8017 0x1E
WRITE 0x8018 0xF4           COMMENT Note: Calculate offset to shell_loop

COMMENT Define hello message
DEFINE hello_msg 0x8030
WRITE 0x8030 0x0D           COMMENT '\r'
WRITE 0x8031 0x0A           COMMENT '\n'
WRITE 0x8032 0x48           COMMENT 'H'
WRITE 0x8033 0x65           COMMENT 'e'
WRITE 0x8034 0x6C           COMMENT 'l'
WRITE 0x8035 0x6C           COMMENT 'l'
WRITE 0x8036 0x6F           COMMENT 'o'
WRITE 0x8037 0x2C           COMMENT ','
WRITE 0x8038 0x20           COMMENT ' '
WRITE 0x8039 0x70           COMMENT 'p'
WRITE 0x803A 0x78           COMMENT 'x'
WRITE 0x803B 0x4F           COMMENT 'O'
WRITE 0x803C 0x53           COMMENT 'S'
WRITE 0x803D 0x20           COMMENT ' '
WRITE 0x803E 0x75           COMMENT 'u'
WRITE 0x803F 0x73           COMMENT 's'
WRITE 0x8040 0x65           COMMENT 'e'
WRITE 0x8041 0x72           COMMENT 'r'
WRITE 0x8042 0x21           COMMENT '!'
WRITE 0x8043 0x0D           COMMENT '\r'
WRITE 0x8044 0x0A           COMMENT '\n'
WRITE 0x8045 0x00           COMMENT null terminator
```

## Building the Module

### 1. Create Sector 2 Binary

Create a modified build script: `build_hello_module.py`

```python
#!/usr/bin/env python3
import sys
sys.path.insert(0, '..')
from build_pxos import PxOSBuilder
from pathlib import Path

# Build sector 2
builder = PxOSBuilder()
builder.build(Path("hello_module_sector2.txt"))

# Write sector 2 binary (starting at 0x8000, but we want bytes from 0x8000-0x87FF)
sector2 = builder.memory[0x8000:0x8200]  # 512 bytes
with open("hello_module.bin", "wb") as f:
    f.write(sector2)

print("hello_module.bin created (512 bytes)")
```

### 2. Combine with Boot Sector

```bash
# Build main boot sector
python3 ../build_pxos.py

# Build hello module (sector 2)
python3 build_hello_module.py

# Combine into multi-sector image
cat ../pxos.bin hello_module.bin > pxos_with_hello.bin

# Test
qemu-system-i386 -fda pxos_with_hello.bin
```

## Testing

1. Boot the combined image
2. Type: `hello` and press Enter
3. Expected output: `Hello, pxOS user!`

## Advanced: Adding More Commands

To add more commands, extend the pattern:

```
COMMENT Check for "help"
WRITE 0x7C70 0xBE           COMMENT MOV SI, input_buffer
WRITE 0x7C71 0x10
WRITE 0x7C72 0x7E
WRITE 0x7C73 0xBF           COMMENT MOV DI, help_cmd_str
WRITE 0x7C74 0x50
WRITE 0x7C75 0x80
WRITE 0x7C76 0xB9           COMMENT MOV CX, 4
WRITE 0x7C77 0x04
WRITE 0x7C78 0x00
WRITE 0x7C79 0xF3           COMMENT REPE CMPSB
WRITE 0x7C7A 0xA6
WRITE 0x7C7B 0x74           COMMENT JE do_help
WRITE 0x7C7C 0x03
```

## Using Jump Tables

For many commands, use a jump table:

```
DEFINE cmd_table 0x8100
COMMENT Entry 0: "hello"
WRITE 0x8100 0x20           COMMENT String address low
WRITE 0x8101 0x80           COMMENT String address high
WRITE 0x8102 0x10           COMMENT Handler address low
WRITE 0x8103 0x80           COMMENT Handler address high
COMMENT Entry 1: "help"
WRITE 0x8104 0x50           COMMENT String address
WRITE 0x8105 0x80
WRITE 0x8106 0x60           COMMENT Handler address
WRITE 0x8107 0x80
```

Then loop through table:

```nasm
parse_command:
    mov si, input_buffer
    mov bx, cmd_table
.loop:
    mov di, [bx]        ; Get string address
    test di, di         ; End of table?
    jz .unknown
    ; Compare strings
    push si
    mov cx, 10          ; Max command length
    repe cmpsb
    pop si
    je .found
    add bx, 4           ; Next entry
    jmp .loop
.found:
    mov ax, [bx+2]      ; Get handler address
    call ax             ; Call handler
    jmp shell_loop
.unknown:
    ; Print "Unknown command"
    jmp shell_loop
```

## Troubleshooting

### Command not recognized
- Check string comparison length
- Verify null terminator
- Check buffer is cleared before input

### System hangs
- Verify jump offsets (calculate carefully!)
- Check stack is set up correctly
- Ensure handlers return or jump back to shell

### Disk read fails
- Verify INT 0x13 parameters
- Check carry flag after read
- Ensure sector 2 exists in image

## Resources

- See [../docs/extensions.md](../docs/extensions.md) for more patterns
- See [../docs/architecture.md](../docs/architecture.md) for memory layout
- See [../docs/primitives.md](../docs/primitives.md) for command reference

---

**Happy hacking!**
